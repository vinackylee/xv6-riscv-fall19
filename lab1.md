# MIT6.S081/6.828 fall2019 LAB1

按照tool中的命令，安装tool和qemu。

make qemu后退出使用Ctrl A + x

#### 实验

sleep 和 pingpong都比较简单，primes思考的时间有点久，然后参考了网上的代码，又把讲义读了一遍，发现很多没有注意到的函数调用细节，终于想明白自己实现了出来。

```
primes思路：

首先有一个进程起始时向第一个管道送入2到35，从子进程开始做的事情就是重复的，有这么几个事情，从读端口拿到上一个进程送来的第一个数将其输出，有数字说明需要创建下一个管道和进程继续传数，本进程继续读数并判断是否是第一个数的倍数，不是则送入刚创建的管道的写端口，子进程重复这个事情（从读端口拿送来的第一个数……）

其中，在传数过程中为了方便端口，将管道的两个口重定向到标准输入输出。注意printf的位置。
```

```
pingpong思路：

主要就是使用pipe进行进程间通信，两个通道进行信息传输。这个比较简单，打印时候记得getpid()。
```

```
find思路：

查找过程主要抄ls.c,改成递归就好了，把输出部分改一下。正则匹配直接抄grep.c。
```

```
xargs思路：

把输入的字符放到命令后面，然后调用exec。使用指针时候留意些。
```



又复习了一下这些系统调用的点：

> pipe
>
> 开辟一段缓冲区，有两个文件描述符，分别是缓冲区的读口和写口。
>
> 使用read进行读pipe，如果缓冲区没有数，则read一直等待写端口写，或者写端口关闭，read返回0。
>
> 通常用于进程间通信

> dup
>
> 复制一个存在的文件描述符，返回文件描述符（一个整数，分配的是目前空着的最小的号）。
>
> 两个文件描述符共享同一个偏移。

> 文件描述符File despcriptors
>
> 一个整数，标识进程可能读的一个打开的文件、目录、设备或者管道等。
>
> 每个进程私有一个从0开始的进程描述符空间。
>
> 0 standard input
>
> 1 standard output
>
> 2 standard error